import json
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from config import BOT_TOKEN, ADMIN_IDS, DATA_FILE

bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()

start_kb = InlineKeyboardMarkup(
    inline_keyboard=[[InlineKeyboardButton(text="‚ñ∂Ô∏è –°–¢–ê–†–¢", callback_data="start")]]
)

def load_data():
    with open(DATA_FILE, "r") as f:
        return json.load(f)

def save_data(data):
    with open(DATA_FILE, "w") as f:
        json.dump(data, f, indent=2)

def log_deletion(entry, reason):
    try:
        with open("deleted_log.json", "r") as f:
            log = json.load(f)
    except:
        log = []

    log.append({
        "name": entry["name"],
        "link": entry["link"],
        "user": entry.get("user"),
        "id": entry.get("id"),
        "date": entry.get("date"),
        "reason": reason
    })

    with open("deleted_log.json", "w") as f:
        json.dump(log, f, indent=2)

@dp.message(Command("start"))
async def handle_start(msg: Message):
    await show_main_menu(msg.from_user.id, msg)

@dp.callback_query(lambda c: c.data == "start")
async def handle_start_button(callback: CallbackQuery):
    await show_main_menu(callback.from_user.id, callback.message)

async def show_main_menu(user_id, message):
    if user_id in ADMIN_IDS:
        kb = InlineKeyboardMarkup(
            inline_keyboard=[
                [InlineKeyboardButton(text="üìã –°–ø–∏—Å–æ–∫", callback_data="list_used")],
                [InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å", callback_data="add_link")],
                [InlineKeyboardButton(text="‚ùå –£–¥–∞–ª–∏—Ç—å", callback_data="delete_link")],
                [InlineKeyboardButton(text="üîç –ü–æ–∏—Å–∫", callback_data="find_link")],
                [InlineKeyboardButton(text="üìä –°—Ç–∞—Ç—É—Å", callback_data="status")],
                [InlineKeyboardButton(text="‚ñ∂Ô∏è –°–¢–ê–†–¢", callback_data="start")]
            ]
        )
        await message.answer("–í—ã –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä. –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=kb)
    else:
        kb = InlineKeyboardMarkup(
            inline_keyboard=[
                [InlineKeyboardButton(text="–ü–æ–ª—É—á–∏—Ç—å", callback_data="get_link")],
                [InlineKeyboardButton(text="–ú–æ–∏ —Å—Å—ã–ª–∫–∏", callback_data="my_links")],
                [InlineKeyboardButton(text="‚ñ∂Ô∏è –°–¢–ê–†–¢", callback_data="start")]
            ]
        )
        await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=kb)

@dp.callback_query(lambda c: c.data == "get_link")
async def handle_get_callback(callback: CallbackQuery):
    data = load_data()
    user_id = str(callback.from_user.id)
    user_links = [u for u in data["used"] if str(u.get("id")) == user_id]

    if len(user_links) >= 5:
        await callback.message.answer("üö´ –õ–∏–º–∏—Ç: –Ω–µ –±–æ–ª–µ–µ 5 —Å—Å—ã–ª–æ–∫ –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.", reply_markup=start_kb)
        return

    if not data["available"]:
        await callback.message.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å—Å—ã–ª–æ–∫.", reply_markup=start_kb)
        return

    entry = data["available"].pop(0)
    name = entry["name"]
    link = entry["link"]
    username = callback.from_user.username or user_id

    data["used"].append({
        "name": name,
        "link": link,
        "user": username,
        "id": user_id,
        "date": callback.message.date.isoformat()
    })
    save_data(data)

    text = f"*–ù–∞–∑–≤–∞–Ω–∏–µ:* {name}\n*–°—Å—ã–ª–∫–∞:* `{link}`"
    await callback.message.answer(text, parse_mode="Markdown", reply_markup=start_kb)

    for admin_id in ADMIN_IDS:
        await bot.send_message(admin_id, f"{username} –ø–æ–ª—É—á–∏–ª —Å—Å—ã–ª–∫—É: {name}")

@dp.callback_query(lambda c: c.data == "my_links")
async def handle_my_links(callback: CallbackQuery):
    data = load_data()
    user_id = str(callback.from_user.id)
    user_links = [u for u in data["used"] if str(u.get("id")) == user_id]

    if not user_links:
        await callback.message.answer("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –≤—ã–¥–∞–Ω–Ω—ã—Ö —Å—Å—ã–ª–æ–∫.", reply_markup=start_kb)
        return

    text = "\n\n".join([
        f"*–ù–∞–∑–≤–∞–Ω–∏–µ:* {u['name']}\n*–°—Å—ã–ª–∫–∞:* `{u['link']}`"
        for u in user_links
    ])
    await callback.message.answer(text, parse_mode="Markdown", reply_markup=start_kb)

@dp.callback_query(lambda c: c.data == "list_used")
async def handle_list_callback(callback: CallbackQuery):
    data = load_data()
    text = "\n".join([
        f"{i+1}. {u['date']} ‚Äî {u['user']} ‚Äî {u['name']}"
        for i, u in enumerate(data["used"])
    ]) or "–ù–µ—Ç –≤—ã–¥–∞–Ω–Ω—ã—Ö —Å—Å—ã–ª–æ–∫."
    await callback.message.answer(text, reply_markup=start_kb)

@dp.callback_query(lambda c: c.data == "status")
async def handle_status_callback(callback: CallbackQuery):
    data = load_data()
    total_available = len(data["available"])
    total_used = len(data["used"])
    last_entry = data["used"][-1] if data["used"] else None

    text = f"üìä –°—Ç–∞—Ç—É—Å:\n‚Ä¢ –î–æ—Å—Ç—É–ø–Ω–æ: {total_available}\n‚Ä¢ –í—ã–¥–∞–Ω–æ: {total_used}"
    if last_entry:
        text += f"\nüïì –ü–æ—Å–ª–µ–¥–Ω—è—è –≤—ã–¥–∞—á–∞:\n{last_entry['date']} ‚Äî {last_entry['user']} ‚Äî {last_entry['name']}"
    await callback.message.answer(text, reply_markup=start_kb)

@dp.callback_query(lambda c: c.data == "add_link")
async def prompt_add_link(callback: CallbackQuery):
    await callback.message.answer("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n`/add`\n`–Ω–∞–∑–≤–∞–Ω–∏–µ * —Å—Å—ã–ª–∫–∞`\n`–Ω–∞–∑–≤–∞–Ω–∏–µ * —Å—Å—ã–ª–∫–∞`", parse_mode="Markdown", reply_markup=start_kb)

@dp.message(Command("add"))
async def handle_add(msg: Message):
    if msg.from_user.id not in ADMIN_IDS:
        return

    lines = msg.text.split("\n")[1:]
    data = load_data()
    count = 0
    skipped = []

    existing_links = {u["link"] for u in data["available"] + data["used"]}

    for line in lines:
        if "*" in line:
            name, link = map(str.strip, line.split("*", 1))
            if link in existing_links:
                skipped.append(name)
                continue
            data["available"].append({"name": name, "link": link})
            count += 1

    save_data(data)

    text = f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ: {count} —Å—Å—ã–ª–æ–∫"
    if skipped:
        text += f"\n‚ö†Ô∏è –ü—Ä–æ–ø—É—â–µ–Ω–æ (–¥—É–±–ª–∏–∫–∞—Ç—ã): {', '.join(skipped)}"
        for admin_id in ADMIN_IDS:
            await bot.send_message(admin_id, f"‚ö†Ô∏è –î—É–±–ª–∏–∫–∞—Ç—ã –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏: {', '.join(skipped)}")

    await msg.answer(text, reply_markup=start_kb)

@dp.callback_query(lambda c: c.data == "delete_link")
async def prompt_delete_link(callback: CallbackQuery):
    await callback.message.answer("–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–º–µ—Ä–∞ –∏ –ø—Ä–∏—á–∏–Ω—É:\n`/delete 1,3 –ø—Ä–∏—á–∏–Ω–∞ —É–¥–∞–ª–µ–Ω–∏—è`", parse_mode="Markdown", reply_markup=start_kb)

@dp.message(Command("delete"))
async def handle_delete(msg: Message):
    if msg.from_user.id not in ADMIN_IDS:
        return

    parts = msg.text.split(maxsplit=2)
    if len(parts) < 2:
        await msg.answer("–ò—Å–ø–æ–ª—å–∑—É–π: /delete <–Ω–æ–º–µ—Ä–∞ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é> [–ø—Ä–∏—á–∏–Ω–∞]", reply_markup=start_kb)
        return

    try:
        indices = sorted(set(int(i.strip()) - 1 for i in parts[1].split(",")), reverse=True)
    except ValueError:
        await msg.answer("–ù–æ–º–µ—Ä–∞ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Ü–µ–ª—ã–º–∏ —á–∏—Å–ª–∞–º–∏", reply_markup=start_kb)
        return

    reason = parts[2] if len(parts) == 3 else "–ë–µ–∑ –ø—Ä–∏—á–∏–Ω—ã"
    data = load_data()
    removed = []

    for i in indices:
        if 0 <= i < len(data["used"]):
            entry = data["used"].pop(i)
            removed.append(entry)
            log_deletion(entry, reason)

            user_id = entry.get("id")
            if user_id:
                try:
                    await bot.send_message(int(user_id), f"üîî –í–∞—à–∞ —Å—Å—ã–ª–∫–∞ '{entry['name']}' –±—ã–ª–∞ —É–¥–∞–ª–µ–Ω–∞.\n–ü—Ä–∏—á–∏–Ω–∞: {reason}")
                except:
                    pass

    save_data(data)
    await msg.answer(f"üóë –£–¥–∞–ª–µ–Ω–æ: {len(removed)} –∑–∞–ø–∏—Å–µ–π", reply_markup=start_kb)

       for admin_id in ADMIN_IDS:
        if removed:
            names = [r["name"] for r in removed]
            await bot.send_message(admin_id, f"üóë –£–¥–∞–ª–µ–Ω–æ: {len(removed)} —Å—Å—ã–ª–æ–∫\n–ü—Ä–∏—á–∏–Ω–∞: {reason}\n–°—Å—ã–ª–∫–∏: {', '.join(names)}")

@dp.message(lambda msg: not msg.text.startswith("/"))
async def fallback(msg: Message):
    await msg.answer("–ù–∞–∂–º–∏—Ç–µ –°–¢–ê–†–¢ –¥–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã", reply_markup=start_kb)

if __name__ == "__main__":
    import asyncio
    asyncio.run(dp.start_polling(bot))
 
